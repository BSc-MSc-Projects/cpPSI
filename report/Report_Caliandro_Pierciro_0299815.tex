\documentclass[10pt]{extarticle}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{biblatex}


\title{Network and System Defense Report\\PSI Scheme implementation}
\author{Caliandro Pierciro - 0299815}


\definecolor{codecolor}{rgb}{0,0.3,0.6}


\lstset{
    basicstyle = \ttfamily\footnotesize,
    deletekeywords={for, if},
    keywordstyle=\color{codecolor},
	language = C++,
	numbers = left,
	numbersep = 2pt,
	showtabs=false,
	tabsize=2,
	otherkeywords={set\_plain\_modulus, set\_coeff\_modulus, PlainModulus, Batching,
	CoeffModulus, BFVDefault, EncryptionParameters, size\_t, bfv},
}


\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}
The following document summarizes the implementation choices made to build a Private Set Intersection (PSI) scheme using homomorphic encryption.\\
PSI is a computational problem in which two or more parties want to know the intersection between a certain set of elements that each one of them has, without revealing the content of the whole set each other.\\
To perform the homomorphic computation, Microsoft SEAL library\cite{1} was used and the scheme built is made of two parties, a \textbf{sender} and a \textbf{receiver}.
\section{PSI scheme overview}
The assumption made are the following:
\begin{itemize}
	\item the receiver and the sender have their private sets D$_r$ and D$_s$, of sizes respectively N$_r$ and N$_s$;
	\item each set is composed of bitstrings of length $\sigma$;
	\item the values N$_r$, N$_s$ and $\sigma$ are public and known;
\end{itemize}
PSI scheme is composed of 3 main steps:
\begin{enumerate}
	\item \textbf{setup}
	\item \textbf{element encryption}
	\item \textbf{intersection computation}
\end{enumerate}
All code is in the \texttt{src} directory, in particular the core files are in \texttt{src/lib}, which contains the file for the logic of receiver and sender, plus utility functions inside \texttt{utils.cpp}.


\subsection{Setup phase and element encryption}
In this step, sender and receiver agree on a fully homomorphic scheme.\\
Inside the code, there is not a "real" agreement using the network or something else, indeed there is a function inside the \texttt{utils.cpp} file where the parameters for the scheme are decided.\\ In particular, the homomorphic scheme used in this implementation is \textbf{BFV}, which allows addition and multiplication over integers.\\This scheme cannot perform arbitrary computations on encrypted data: in fact, each ciphertext has a specific quantity that is called \textbf{invariant noise budget}, measured in bits, which depends on the choice of the scheme's parameters and is consumed in homomorphic operations.\\Once this noise budget reaches 0, the resulting ciphertext is corrupted and so it is not possible to obtain the correct result in decryption.\\The 3 main parameters that one needs to set up in the \texttt{EncryptionParameters} class for the scheme are:
\begin{itemize}
	\item \textbf{degree of the polynomial modulus}: this parameter must be a power of 2, and represents the degree of a power-of-two cyclotomic polynomial. The larger this value is, the more complicated the encryption operations that can be performed, but also the size of the resulting ciphertext will be higher;
	\item \textbf{ciphertext coefficient modulus}: this value is a product of distinct prime numbers, each up to 60 bits. The choice of this parameter implies larger noise budget, but there is an upper bound determined by the polynomial modulus degree;
	\item \textbf{plaintext modulus}, specific for the BFV scheme. This parameter determines the size of the plaintext data type and the consumption of noise budget, so it is essential trying to keep the data type for the plaintext smaller for better performance.\\The noise budget in a freshly encrypted ciphertext is:
	\begin{equation}
		\simeq log_2(\tfrac{\text{coefficient\_modulus}}{\text{plaintext\_modulus}})
	\end{equation}
	and the noise consumption in a homomorphic multiplication is 
	\begin{equation}
		log_2(\text{plaintext\_modulus}) + \text{other terms}
	\end{equation}
\end{itemize}
The choice of parameters is made as follows:
\lstinputlisting[linerange={24-32}]{../src/lib/utils.cpp}
After choosing these parameters, the receiver proceeds to generate a pair of public/private keys that will be used to encrypt and decrypt the data. These keys must remain secret.\\
Since the keys will be required for the receiver in following steps, they have been saved in a suited class, which is \texttt{Receiver}, implemented in file \texttt{src/lib/utils.h} so that it can easily be imported where it is needed.\\This class also keeps the receiver dataset, that will be accessed to check which strings belong to the intersection.\\
After generating the keys, in function \texttt{crypt\_dataset}, the receiver dataset is opened from the file and encrypted by the receiver.\\To do so, the dataset is treated as a vector of \texttt{uint64\_t}, which will be interpreted as a matrix. This matrix is first encoded (using \texttt{BatchEncoder}), encrypted and the resulting ciphertext is passed to the sender.

\subsection{Intersection computation}
In this phase, suppose that the sender receives the encrypted ciphertext from the receiver, which is a matrix where each entry is one of the encrypted values, c$_i$.\\What the sender has to do is compute, for each element i of the received encrypted set, what follows:
\begin{itemize}
    \item generate a random, non-zero, value r$_i$ which happens in \texttt{gen\_rand} function;
    \item homomorphically computes:
        \begin{equation}
            d_i = r_i \cdot \sum\limits_{n_s \in D_s} (c_i - n_s)
        \end{equation}
    where D$_s$ is sender's dataset
\end{itemize}
all this computation is made by the function \texttt{homomorphic\_computation}, so in the end, the sender will produce another encrypted matrix d$_i$.\\
An important aspect of performance in this computation is the use of \textbf{relinearization keys}: these keys are required to reduce the size of the resulting ciphertext, so that applying these after each multiplication the size can remain equals to 2.

\subsection{Response extraction}
In the last step, the receiver gets the homomorphic computation of the sender, and can extract the intersection between the dataset, considering each element i of the sender's encrypted computation:
\begin{equation}
    I = D_r \cap D_s = \{n_r: \textbf{Decrypt}(\textbf{sk}, d_i) = 0\}
\end{equation}
where 
\begin{itemize}
	\item $D_r$ and $D_s$ are, respectively, receiver's and sender's private datasets;
	\item I will be the resulting intersection;
\end{itemize}
So, receiver can know which element belongs to the intersection without knowing the full set of the sender.\\
The multiplication for a random value will avoid any hint about the element not belonging to that intersection.

\section{Results and limitations}
Tests for the scheme are in the file \texttt{src/test/test.cpp}: in particular, the aim of the test is:
\begin{itemize}
    \item verify that the scheme is working properly. To do so, the dataset for sender and receiver are created inside the file, and the intersection is computed and stored. To simplify, the size of both dataset is the same.\\The test will assert that the intersection computed by the receiver and the saved one are the same;
    \item furthermore, some data for the test as gathered, such as:
        \begin{itemize}
            \item the time needed to complete the full scheme;
            \item the resulting noise after the computation;
            \item the parameter of the scheme, in terms of the \texttt{poly\_modulus\_degree} 
        \end{itemize}
\end{itemize}
data obtained are summarized in the following table:\\
\begin{table}[!ht]
	\begin{tabular}{||c|c|c|c|c||}
		\hline
		Modulus length & Bitstring size	& Dataset size	& Computation Time	& Remaining noise\\
		\hline\hline
		8192 & 24 & 4 & 2,01757 & 25\\
		\hline
		8192 & 24 & 6 & 3,71375 & 0\\
		\hline
		8192 & 24 & 8 & 6,04167 & 0\\
		\hline
		8192 & 24 & 10 & 8,95375 & 0\\
		\hline
	\end{tabular}
	\caption{Test result for polynomial modulus degree of 8192 bit, with no relinearization}
\end{table}

\begin{table}[!hb]
	\begin{tabular}{||c|c|c|c|c||}
		\hline
		Modulus length & Bitstring size	& Dataset size	& Computation Time	& Remaining noise\\
		\hline\hline
		16384 & 24 & 4 & 8,62892 & 237\\
		\hline
		16384 & 24 & 6 & 15,7851 & 170\\
		\hline
		16384 & 24 & 8 & 25,1823 & 103\\
		\hline
		16384 & 24 & 10 & 36,131 & 37\\
		\hline
	\end{tabular}
	\caption{Test result for polynomial modulus degree of 16384 bit, with no relinearization}
\end{table}
The same test has been run using relinerization keys, showing an important advantage in terms of the time required to compute the whole scheme, as the size of the dataset grows:\\
\begin{table}[!ht]
    \begin{tabular}{||c|c|c|c|c||}
    	\hline
        Modulus length & Bitstring size	& Dataset size	& Computation Time	& Remaining noise\\
        \hline\hline
        8192 & 24 & 4 & 1,82994 & 24\\
        \hline
        8192 & 24 & 6 & 2,78646 & 0\\
        \hline
        8192 & 24 & 8 & 3,77176 & 0\\
        \hline
        8192 & 24 & 10 & 4,92907 & 0\\
        \hline
    \end{tabular}
	\caption{Test result for polynomial modulus degree of 8192 bit, with relinearization}
\end{table}

\begin{table}[!ht]
	\begin{tabular}{||c|c|c|c|c||}
		\hline
		Modulus length & Bitstring size	& Dataset size	& Computation Time	& Remaining noise\\
		\hline\hline
		16384 & 24 & 4 & 8,56984 & 237\\
		\hline
		16384 & 24 & 6 & 13,1483 & 170\\
		\hline
		16384 & 24 & 8 & 17,7195 & 103\\
		\hline
		16384 & 24 & 10 & 22,0732 & 36\\
		\hline
	\end{tabular}
\caption{Test result for polynomial modulus degree of 16384 bit, with relinearization}
\end{table}

\newpage
There are some limitation that have been found while developing the scheme and that have been confirmed by the results:
\begin{enumerate}
	\item the first limitation shown by the data result is in the invariant noise: even with a small dataset, for a modulus of size 8192 bits, the noise goes soon to 0 meaning that it will be not possible for the receiver to decrypt the result correctly.\\Increasing the modulus size allows to treat a larger dataset, but the performance are badly affected;
	\item the whole implementation was derived on the basis of the examples offered by the library itself, which unfortunately does not have any further documentation for example to choose a finer grained value for the coefficient module or the plaintext modulus manually.\\To do so it would be necessary a deeper knowledge of the source code;
	\item the choice of \texttt{uint64\_t} as datatype is such that when the bitstring exceeds 24 bit of size, the multiplication between values can result in an overflow, so even if decryption can be performed, because the noise is greater than 0, the resulting intersection is not the right one (expected one).
\end{enumerate}

\begin{thebibliography}{12}
	\bibitem{1} Microsoft SEAL library, see \href{https://github.com/Microsoft/SEAL}{https://github.com/Microsoft/SEAL}
\end{thebibliography}





\end{document}

